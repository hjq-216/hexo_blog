{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/assets/IMG_1641.JPG","path":"assets/IMG_1641.JPG","modified":1,"renderable":1},{"_id":"themes/yilia/source/assets/o_1dfilp8ruo521thr1hvf18ji17soa.png","path":"assets/o_1dfilp8ruo521thr1hvf18ji17soa.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/.DS_Store","hash":"3d0bef2ee93aa857b8cae17dfabd7c39d758acf2","modified":1612763463395},{"_id":"source/.DS_Store","hash":"036c55d76b76016fa8f6a3be57bff44d5957e8fe","modified":1613212221746},{"_id":"source/_posts/二叉树的遍历非递归算法.md","hash":"2ed4638e903c66c70a71c59cceccd7ec71a63e47","modified":1613213130832},{"_id":"source/_posts/Java核心技术卷一学习笔记（二）.md","hash":"70c3258d48aefddcd7aa276b08e226d184e2132c","modified":1613213042049},{"_id":"source/_posts/Java核心技术卷一学习（一）.md","hash":"c7430476c97854065075974b68cde1355b0762ed","modified":1613213056853},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1612697793328},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1612697793322},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1612697793322},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1612697793323},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1612697793323},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1612697793323},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1612697793323},{"_id":"themes/yilia/_config.yml","hash":"d06f54eca33357907da87c26160a4209e980ddac","modified":1612751734036},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1612697793330},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1612697793324},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1612697793324},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1612697793346},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1612697793324},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1612697793324},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1612697793324},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1612697793324},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1612697793329},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1612697793328},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1612697793329},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1612697793329},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1612697793329},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1612697793329},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1612697793329},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1612697793344},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1612697793330},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1612697793324},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1612697793324},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1612697793324},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1612697793325},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1612697793346},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1612697793341},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1612697793325},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1612697793325},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1612697793325},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"167998928f91f891e24507d7364c7f34d8c50285","modified":1612750312789},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1612697793325},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1612697793325},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1612697793325},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1612697793326},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1612697793326},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1612697793326},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1612697793328},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1612697793328},{"_id":"themes/yilia/source/assets/.DS_Store","hash":"e6a7bc2734c03787c21cff6171eb303c80d787b1","modified":1612750881004},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1612697793341},{"_id":"themes/yilia/source/assets/o_1dfilp8ruo521thr1hvf18ji17soa.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1612749138505},{"_id":"themes/yilia/source/assets/IMG_1641.JPG","hash":"54ddc9ce422837ad57c729b25c26b8bbeed4c6c1","modified":1609433122000},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1612697793342},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1612697793342},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1612697793342},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1612697793343},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1612697793343},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1612697793343},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1612697793343},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1612697793330},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1612697793344},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1612697793330},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1612697793330},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1612697793331},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1612697793330},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1612697793331},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1612697793331},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1612697793331},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1612697793331},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1612697793334},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1612697793334},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1612697793332},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1612697793335},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1612697793336},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1612697793335},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1612697793336},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1612697793336},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1612697793336},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1612697793337},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1612697793337},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1612697793337},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1612697793337},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1612697793337},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1612697793338},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1612697793338},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1612697793338},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1612697793338},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1612697793339},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1612697793339},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1612697793339},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1612697793339},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1612697793340},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1612697793340},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1612697793340},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1612697793340},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1612697793341},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1612697793341},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1612697793340},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1612697793326},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1612697793341},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1612697793326},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1612697793326},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1612697793326},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1612697793326},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1612697793327},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1612697793327},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1612697793327},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1612697793327},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1612697793327},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1612697793331},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1612697793332},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1612697793332},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1612697793332},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1612697793332},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1612697793333},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1612697793335},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1612697793334},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1612697793333},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1612697793334},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1612697793335},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1612697793335},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1612697793345},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1612697793346},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1612697793328},{"_id":"public/content.json","hash":"7ba88127265e4c48e1f62da9c3dda41203d3e746","modified":1613213136215},{"_id":"public/2021/02/13/二叉树的遍历非递归算法/index.html","hash":"f5e32412170fa02c6bec2d6ccdb4c88ffbfcf061","modified":1613213136215},{"_id":"public/2021/02/13/Java核心技术卷一学习笔记（二）/index.html","hash":"8b0665bbe68449c91de3637fcd5ce13451ed2ed6","modified":1613213136215},{"_id":"public/2021/02/08/Java核心技术卷一学习（一）/index.html","hash":"7570d4b0f17bf48a90a764abcff896e03f7e8081","modified":1613213136215},{"_id":"public/archives/index.html","hash":"7b07e7b5e36a4b51c3396f03e355087b8c5817f8","modified":1613213136215},{"_id":"public/archives/2021/index.html","hash":"940e5c563a15e09783d6ae9f32ac95bcf6772e8c","modified":1613213136215},{"_id":"public/archives/2021/02/index.html","hash":"bcb3711db68cb1a217db446ceaba220ae2f40f2b","modified":1613213136215},{"_id":"public/index.html","hash":"3970549fab1075293e27ea3aa99869c6e73969d7","modified":1613213136215},{"_id":"public/tags/Java学习/index.html","hash":"d7eae614230c0ab45a010308ee3df97b0110695a","modified":1613213136215},{"_id":"public/tags/数据结构与算法/index.html","hash":"e7d8dbba68fca4531ac6e4498851cbbb07bd1829","modified":1613213136215},{"_id":"public/assets/o_1dfilp8ruo521thr1hvf18ji17soa.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1613213136215},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1613213136215},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1613213136215},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1613213136215},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1613213136215},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1613213136215},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1613213136215},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1613213136215},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1613213136215},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1613213136215},{"_id":"public/assets/IMG_1641.JPG","hash":"54ddc9ce422837ad57c729b25c26b8bbeed4c6c1","modified":1613213136215},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1613213136215},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1613213136215},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1613213136215},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1613213136215}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Java核心技术卷一学习笔记（二）","date":"2021-02-13T05:38:06.000Z","_content":"\n# 对象与类\n\n<!--more-->\n\n## 1 面向对象程序设计概述\n\n- 在Java中，所有的类都扩展自Object类\n\n- 在类之间有三种常见的关系\n\n    - 依赖（uses-a）：如果一个类的方法使用或操纵另一个类的对象，就说一个类依赖于另一个类\n    \n    - 聚合（has-a）：一个类包含着另一个类的对象\n\n    - 继承（is-a）\n\n- 对象变量并没有实际包含一个对象，它只是引用一个对象。在Java中，任何对象变量的值都是对储存在另外一个地方的某个对象的引用。区别于C++的引用，Java的对象变量更类似与C++的对象指针，且两者初始化语法类似。\n\n    C++：Date* birthday = new Date();\n\n    Java: Date birthday = new Date();\n\n## 2 使用预定义类及用户自定义类\n\n- 尽量不要用public标记实例字段，这会破坏封装性\n\n- Java构造器工作方式与C++一样，但是所有Java对象都是在堆中构造，构造器总是结合new操作符一起使用，不可像C++一样忘记new操作符：A a(5);//C++,not java\n\n- 在所有方法中都不要使用与实例字段同名的变量\n\n- 同样可以使用var关键字声明对象，但只能用于方法中的局部变量。参数和字段的类型必须声明。\n\n- 在C++中，通常在类的外面定义方法，在类体内定义方法会自动内联。但是，在Java中，所有方法都必须在类的内部定义，但并不表示它们是内联方法。是否将某个方法设置为内联方法是Java虚拟机的任务。即时编译器会监视那些简短、经常调用而且没有被覆盖的方法调用，并进行优化。\n\n- 方法可以访问所属类任何对象的私有特性，不仅限于隐式参数。\n\n- 可以将实例字段定义为final，这样的字段必须在构造对象时初始化。但对于可变的类，使用final修饰符会造成混乱。例如：\n\n```\nprivate final StringBuilder evaluations;\n```\nfinal关键字只是表示存储在evaluations变量中的对象引用不会再指示另外一个不同的StringBuilder对象。不过这个对象本身可以更改：\n```\nevaluations.append(LocalDate.now()+\":Gold star!\\n\");\n```\n\n## 3 静态字段与静态方法\n\n- static修饰的字段，每个类只有一个这样的字段，与C++类似。\n\n- 静态方法是不在对象上执行的方法，可以认为静态方法是没有this参数的方法，但是，静态方法可以访问静态字段。\n\n- 在下面两种情况下可以使用静态方法：\n\n    - 方法不需要访问对象状态，因为它需要的所有参数都通过显示参数提供\n\n    - 方法只需要访问类的静态字段\n\n- 静态方法还有另一种常见的用途。类似NumberFormat的类使用静态工厂方法来构造对象。\n\n```\nNumberFormat currencyFormatter = NumberFormat.getCurrencyInstance();\nNumberFormat percentFormatter = NumberFormat.getPercentInstance();\ndouble x = 0.1;\nSystem.out.println(currencyFormatter.format(x));//$0.10\nSystem.out.println(percentFormatter.format(x));//10%\n```\n\n为什么要使用静态工厂方法？\n\n1. 无法命名构造器。构造器的名字必须与类名相同。但是这里希望有两个不同的名字，分别得到货币实例和百分比实例。\n\n2. 使用构造器时，无法改变所构造对象的类型。而工厂方法实际上将返回DecimalFormat类的对象。\n\n## 4 方法参数\n\n- Java总是采用按值调用。方法不能修改传递给它的任何参数变量的内容。\n","source":"_posts/Java核心技术卷一学习笔记（二）.md","raw":"---\ntitle: Java核心技术卷一学习笔记（二）\ndate: 2021-02-13 13:38:06\ntags: Java学习\n---\n\n# 对象与类\n\n<!--more-->\n\n## 1 面向对象程序设计概述\n\n- 在Java中，所有的类都扩展自Object类\n\n- 在类之间有三种常见的关系\n\n    - 依赖（uses-a）：如果一个类的方法使用或操纵另一个类的对象，就说一个类依赖于另一个类\n    \n    - 聚合（has-a）：一个类包含着另一个类的对象\n\n    - 继承（is-a）\n\n- 对象变量并没有实际包含一个对象，它只是引用一个对象。在Java中，任何对象变量的值都是对储存在另外一个地方的某个对象的引用。区别于C++的引用，Java的对象变量更类似与C++的对象指针，且两者初始化语法类似。\n\n    C++：Date* birthday = new Date();\n\n    Java: Date birthday = new Date();\n\n## 2 使用预定义类及用户自定义类\n\n- 尽量不要用public标记实例字段，这会破坏封装性\n\n- Java构造器工作方式与C++一样，但是所有Java对象都是在堆中构造，构造器总是结合new操作符一起使用，不可像C++一样忘记new操作符：A a(5);//C++,not java\n\n- 在所有方法中都不要使用与实例字段同名的变量\n\n- 同样可以使用var关键字声明对象，但只能用于方法中的局部变量。参数和字段的类型必须声明。\n\n- 在C++中，通常在类的外面定义方法，在类体内定义方法会自动内联。但是，在Java中，所有方法都必须在类的内部定义，但并不表示它们是内联方法。是否将某个方法设置为内联方法是Java虚拟机的任务。即时编译器会监视那些简短、经常调用而且没有被覆盖的方法调用，并进行优化。\n\n- 方法可以访问所属类任何对象的私有特性，不仅限于隐式参数。\n\n- 可以将实例字段定义为final，这样的字段必须在构造对象时初始化。但对于可变的类，使用final修饰符会造成混乱。例如：\n\n```\nprivate final StringBuilder evaluations;\n```\nfinal关键字只是表示存储在evaluations变量中的对象引用不会再指示另外一个不同的StringBuilder对象。不过这个对象本身可以更改：\n```\nevaluations.append(LocalDate.now()+\":Gold star!\\n\");\n```\n\n## 3 静态字段与静态方法\n\n- static修饰的字段，每个类只有一个这样的字段，与C++类似。\n\n- 静态方法是不在对象上执行的方法，可以认为静态方法是没有this参数的方法，但是，静态方法可以访问静态字段。\n\n- 在下面两种情况下可以使用静态方法：\n\n    - 方法不需要访问对象状态，因为它需要的所有参数都通过显示参数提供\n\n    - 方法只需要访问类的静态字段\n\n- 静态方法还有另一种常见的用途。类似NumberFormat的类使用静态工厂方法来构造对象。\n\n```\nNumberFormat currencyFormatter = NumberFormat.getCurrencyInstance();\nNumberFormat percentFormatter = NumberFormat.getPercentInstance();\ndouble x = 0.1;\nSystem.out.println(currencyFormatter.format(x));//$0.10\nSystem.out.println(percentFormatter.format(x));//10%\n```\n\n为什么要使用静态工厂方法？\n\n1. 无法命名构造器。构造器的名字必须与类名相同。但是这里希望有两个不同的名字，分别得到货币实例和百分比实例。\n\n2. 使用构造器时，无法改变所构造对象的类型。而工厂方法实际上将返回DecimalFormat类的对象。\n\n## 4 方法参数\n\n- Java总是采用按值调用。方法不能修改传递给它的任何参数变量的内容。\n","slug":"Java核心技术卷一学习笔记（二）","published":1,"updated":"2021-02-13T10:44:02.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckl3lg6n10000z09j3a481kwq","content":"<h1 id=\"对象与类\"><a href=\"#对象与类\" class=\"headerlink\" title=\"对象与类\"></a>对象与类</h1><a id=\"more\"></a>\n\n<h2 id=\"1-面向对象程序设计概述\"><a href=\"#1-面向对象程序设计概述\" class=\"headerlink\" title=\"1 面向对象程序设计概述\"></a>1 面向对象程序设计概述</h2><ul>\n<li><p>在Java中，所有的类都扩展自Object类</p>\n</li>\n<li><p>在类之间有三种常见的关系</p>\n<ul>\n<li><p>依赖（uses-a）：如果一个类的方法使用或操纵另一个类的对象，就说一个类依赖于另一个类</p>\n</li>\n<li><p>聚合（has-a）：一个类包含着另一个类的对象</p>\n</li>\n<li><p>继承（is-a）</p>\n</li>\n</ul>\n</li>\n<li><p>对象变量并没有实际包含一个对象，它只是引用一个对象。在Java中，任何对象变量的值都是对储存在另外一个地方的某个对象的引用。区别于C++的引用，Java的对象变量更类似与C++的对象指针，且两者初始化语法类似。</p>\n<p>  C++：Date* birthday = new Date();</p>\n<p>  Java: Date birthday = new Date();</p>\n</li>\n</ul>\n<h2 id=\"2-使用预定义类及用户自定义类\"><a href=\"#2-使用预定义类及用户自定义类\" class=\"headerlink\" title=\"2 使用预定义类及用户自定义类\"></a>2 使用预定义类及用户自定义类</h2><ul>\n<li><p>尽量不要用public标记实例字段，这会破坏封装性</p>\n</li>\n<li><p>Java构造器工作方式与C++一样，但是所有Java对象都是在堆中构造，构造器总是结合new操作符一起使用，不可像C++一样忘记new操作符：A a(5);//C++,not java</p>\n</li>\n<li><p>在所有方法中都不要使用与实例字段同名的变量</p>\n</li>\n<li><p>同样可以使用var关键字声明对象，但只能用于方法中的局部变量。参数和字段的类型必须声明。</p>\n</li>\n<li><p>在C++中，通常在类的外面定义方法，在类体内定义方法会自动内联。但是，在Java中，所有方法都必须在类的内部定义，但并不表示它们是内联方法。是否将某个方法设置为内联方法是Java虚拟机的任务。即时编译器会监视那些简短、经常调用而且没有被覆盖的方法调用，并进行优化。</p>\n</li>\n<li><p>方法可以访问所属类任何对象的私有特性，不仅限于隐式参数。</p>\n</li>\n<li><p>可以将实例字段定义为final，这样的字段必须在构造对象时初始化。但对于可变的类，使用final修饰符会造成混乱。例如：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final StringBuilder evaluations;</span><br></pre></td></tr></table></figure>\n<p>final关键字只是表示存储在evaluations变量中的对象引用不会再指示另外一个不同的StringBuilder对象。不过这个对象本身可以更改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evaluations.append(LocalDate.now()+&quot;:Gold star!\\n&quot;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-静态字段与静态方法\"><a href=\"#3-静态字段与静态方法\" class=\"headerlink\" title=\"3 静态字段与静态方法\"></a>3 静态字段与静态方法</h2><ul>\n<li><p>static修饰的字段，每个类只有一个这样的字段，与C++类似。</p>\n</li>\n<li><p>静态方法是不在对象上执行的方法，可以认为静态方法是没有this参数的方法，但是，静态方法可以访问静态字段。</p>\n</li>\n<li><p>在下面两种情况下可以使用静态方法：</p>\n<ul>\n<li><p>方法不需要访问对象状态，因为它需要的所有参数都通过显示参数提供</p>\n</li>\n<li><p>方法只需要访问类的静态字段</p>\n</li>\n</ul>\n</li>\n<li><p>静态方法还有另一种常见的用途。类似NumberFormat的类使用静态工厂方法来构造对象。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NumberFormat currencyFormatter &#x3D; NumberFormat.getCurrencyInstance();</span><br><span class=\"line\">NumberFormat percentFormatter &#x3D; NumberFormat.getPercentInstance();</span><br><span class=\"line\">double x &#x3D; 0.1;</span><br><span class=\"line\">System.out.println(currencyFormatter.format(x));&#x2F;&#x2F;$0.10</span><br><span class=\"line\">System.out.println(percentFormatter.format(x));&#x2F;&#x2F;10%</span><br></pre></td></tr></table></figure>\n<p>为什么要使用静态工厂方法？</p>\n<ol>\n<li><p>无法命名构造器。构造器的名字必须与类名相同。但是这里希望有两个不同的名字，分别得到货币实例和百分比实例。</p>\n</li>\n<li><p>使用构造器时，无法改变所构造对象的类型。而工厂方法实际上将返回DecimalFormat类的对象。</p>\n</li>\n</ol>\n<h2 id=\"4-方法参数\"><a href=\"#4-方法参数\" class=\"headerlink\" title=\"4 方法参数\"></a>4 方法参数</h2><ul>\n<li>Java总是采用按值调用。方法不能修改传递给它的任何参数变量的内容。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"对象与类\"><a href=\"#对象与类\" class=\"headerlink\" title=\"对象与类\"></a>对象与类</h1>","more":"<h2 id=\"1-面向对象程序设计概述\"><a href=\"#1-面向对象程序设计概述\" class=\"headerlink\" title=\"1 面向对象程序设计概述\"></a>1 面向对象程序设计概述</h2><ul>\n<li><p>在Java中，所有的类都扩展自Object类</p>\n</li>\n<li><p>在类之间有三种常见的关系</p>\n<ul>\n<li><p>依赖（uses-a）：如果一个类的方法使用或操纵另一个类的对象，就说一个类依赖于另一个类</p>\n</li>\n<li><p>聚合（has-a）：一个类包含着另一个类的对象</p>\n</li>\n<li><p>继承（is-a）</p>\n</li>\n</ul>\n</li>\n<li><p>对象变量并没有实际包含一个对象，它只是引用一个对象。在Java中，任何对象变量的值都是对储存在另外一个地方的某个对象的引用。区别于C++的引用，Java的对象变量更类似与C++的对象指针，且两者初始化语法类似。</p>\n<p>  C++：Date* birthday = new Date();</p>\n<p>  Java: Date birthday = new Date();</p>\n</li>\n</ul>\n<h2 id=\"2-使用预定义类及用户自定义类\"><a href=\"#2-使用预定义类及用户自定义类\" class=\"headerlink\" title=\"2 使用预定义类及用户自定义类\"></a>2 使用预定义类及用户自定义类</h2><ul>\n<li><p>尽量不要用public标记实例字段，这会破坏封装性</p>\n</li>\n<li><p>Java构造器工作方式与C++一样，但是所有Java对象都是在堆中构造，构造器总是结合new操作符一起使用，不可像C++一样忘记new操作符：A a(5);//C++,not java</p>\n</li>\n<li><p>在所有方法中都不要使用与实例字段同名的变量</p>\n</li>\n<li><p>同样可以使用var关键字声明对象，但只能用于方法中的局部变量。参数和字段的类型必须声明。</p>\n</li>\n<li><p>在C++中，通常在类的外面定义方法，在类体内定义方法会自动内联。但是，在Java中，所有方法都必须在类的内部定义，但并不表示它们是内联方法。是否将某个方法设置为内联方法是Java虚拟机的任务。即时编译器会监视那些简短、经常调用而且没有被覆盖的方法调用，并进行优化。</p>\n</li>\n<li><p>方法可以访问所属类任何对象的私有特性，不仅限于隐式参数。</p>\n</li>\n<li><p>可以将实例字段定义为final，这样的字段必须在构造对象时初始化。但对于可变的类，使用final修饰符会造成混乱。例如：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final StringBuilder evaluations;</span><br></pre></td></tr></table></figure>\n<p>final关键字只是表示存储在evaluations变量中的对象引用不会再指示另外一个不同的StringBuilder对象。不过这个对象本身可以更改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evaluations.append(LocalDate.now()+&quot;:Gold star!\\n&quot;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-静态字段与静态方法\"><a href=\"#3-静态字段与静态方法\" class=\"headerlink\" title=\"3 静态字段与静态方法\"></a>3 静态字段与静态方法</h2><ul>\n<li><p>static修饰的字段，每个类只有一个这样的字段，与C++类似。</p>\n</li>\n<li><p>静态方法是不在对象上执行的方法，可以认为静态方法是没有this参数的方法，但是，静态方法可以访问静态字段。</p>\n</li>\n<li><p>在下面两种情况下可以使用静态方法：</p>\n<ul>\n<li><p>方法不需要访问对象状态，因为它需要的所有参数都通过显示参数提供</p>\n</li>\n<li><p>方法只需要访问类的静态字段</p>\n</li>\n</ul>\n</li>\n<li><p>静态方法还有另一种常见的用途。类似NumberFormat的类使用静态工厂方法来构造对象。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NumberFormat currencyFormatter &#x3D; NumberFormat.getCurrencyInstance();</span><br><span class=\"line\">NumberFormat percentFormatter &#x3D; NumberFormat.getPercentInstance();</span><br><span class=\"line\">double x &#x3D; 0.1;</span><br><span class=\"line\">System.out.println(currencyFormatter.format(x));&#x2F;&#x2F;$0.10</span><br><span class=\"line\">System.out.println(percentFormatter.format(x));&#x2F;&#x2F;10%</span><br></pre></td></tr></table></figure>\n<p>为什么要使用静态工厂方法？</p>\n<ol>\n<li><p>无法命名构造器。构造器的名字必须与类名相同。但是这里希望有两个不同的名字，分别得到货币实例和百分比实例。</p>\n</li>\n<li><p>使用构造器时，无法改变所构造对象的类型。而工厂方法实际上将返回DecimalFormat类的对象。</p>\n</li>\n</ol>\n<h2 id=\"4-方法参数\"><a href=\"#4-方法参数\" class=\"headerlink\" title=\"4 方法参数\"></a>4 方法参数</h2><ul>\n<li>Java总是采用按值调用。方法不能修改传递给它的任何参数变量的内容。</li>\n</ul>"},{"title":"Java核心技术卷一学习笔记（一）","date":"2021-02-08T04:31:14.000Z","_content":"\n# Java的基本程序设计结构\n\n<!--more-->\n\n## 1 一个简单的Java应用程序\n\n- Java应用程序中的全部内容都必须放置在类中\n\n- 命名规范：类名必须以大写字母开头，若名字有多个单词组成，则每个单词首字母都大写，驼峰命名法\n\n- 源代码文件名必须与该文件中的公共类名字相同\n\n- Java1.4以后，main方法必须是public\n\n- 输出：println方法会在输出后增加一个换行符，若不需要，使用print方法\n\n## 2 数据类型\n\n- Java是一种强类型语言。每一个变量都需要声明一种类型。\n\n- Java与C++不同，整型不会根据不同的处理器选择不同大小，int统一为4字节，short为2字节，long为8字节，byte为1字节。\n\n- 从Java7开始，用0b开头表示二进制数\n\n- 从Java7开始，数字字面量可以添加下划线，编译器会去除下划线，如1_000_000等价于1000000\n\n- Integer类和Long类都提供了处理无符号数的方法\n\n## 3 浮点类型\n\n- 没有后缀F的默认为double型\n\n- 不能使用 x==Double.NaN来判断一个特定值是否不为数字，而应该使用Double.isNaN（x）\n\n## 4 Unicode与char类型\n\n- 码点（codePoint）是指一个与编码表中的某个字符对应的代码值\n\n- char类型代表一个字符，即一个代码单元\n\n- 不可用char来存储一个码点，因为一个码点可能对应两个代码单元\n\n## 5 变量\n\n- 如果可以从变量的初始值判断数值类型，就不需要再声明类型，使用var关键字即可\n\n```\nvar x = 12;//x为int型\nvar y = \"hello\";//y为string\n```\n\n- 与C++不同，Java常量关键字使用final，若某个常量需要被多个方法使用，声明为static final，若需要在类外使用，声明为public static final ，通过Object.*cast*使用即可。\n\n- 枚举类型：枚举类型变量只能储存在这个类型声明中给定的某个枚举值或者null\n\n## 6 位运算符\n\n- “>>>”运算符会用0填充高位，而“>>“会根据符号位填充\n\n- 移位运算符的右操作数要完成模32的运算（若左操作数为long，则要模64），如1<<35 等价于 1<<3\n\n## 7 字符串\n\n- Java的String是一个类，不是一个字符串，与C++不同，String也不是一个字符数组，而类似与字符串指针，但不能采用指针的方式运算。\n\n- Java的String类是不可变的，因此字符串在存储池中是可以共享的，如果某个字符块不再使用，Java会自动回收，不会造成内存泄漏。\n\n- 由于String对象类似指针，因此不可使用==来比较两个字符串是否相等，因为两个对象可能共享同一个字符串，需要使用equals方法。\n\n- 如果在一个null值上调用方法，会抛出异常。\n\n- String、StringBuffer、StringBuilder对比\n\n    - String为不可变的，虽然两个String对象可以相加，但每次拼接，都会构建一个新的字符串，耗时且浪费空间。可以等价于：\n\n    ```\n    public final class String\n    {\n        private final char value[];\n        ···\n    }\n    ```\n\n    - 而StringBuffer和StringBuilder底层等价于一个普通数组，是可变的，因此拼接字符串时是对其本身对象进行操作，不会产生新的对象。使用.append方法即可拼接字符串。\n\n    - StringBuffer与StringBuilder，前者是线程安全的，因为其中很多方法被synchronized修饰，相当于锁机制，而后者没有，但后者效率偏高。\n\n    - 如果会多次修改字符串，且不考虑线程安全，使用StringBuilder，考虑线程安全应该使用StringBuffer。\n\n## 8 输入输出\n\n- 输入需要创建Scanner对象：\n\n```\nScanner in = new Scanner(System.in);\nString name = in.nextLine();//一行字符串，包括空格\nString name = in.next();//一个单词，不包括空格\nint age = in.nextInt();//输入数字\n```\n\n如果需要输入密码，应该使用Console，在控制台不会显示出输入的密码，输入完成后应立即覆盖数组：\n\n```\nConsole cons = System.console();\nString username = cons.readLine(\"user name:\");\nchar [] password = cons.readPassword(\"Password:\");\n```\n\n- 格式化输出：可以用一个格式字符串指示要格式化的索引\n\n```\nSyetem.out.println(\"%1$s %2$tB %2$te %2$tY\",\"Dut Date:\",new Date());\n```\n\n- 文件输入输出：同样需要一个Scanner对象：\n\n```\nScanner in = new Scanner(Path.of(\"myfile.txt\"),StandardCharsets.UFT-8);\n```\n\n注意：可以构造一个参数为字符串的Scanner对象，但会把字符串解析为数据而不是文件名\n\n## 9 控制流程\n\n- Java中不允许在嵌套的块内有多个同名变量\n\n- 循环时，检测两个浮点数要格外小心，因为舍入误差可能造成死循环\n\n```\nfor(double x = 0;x!=10;x+=0.1) ...\n```\n\n- Java中没有goto语句，但break可以有标签，在标签指定的循环中使用 break 标签可以跳出最外层循环\n\n## 10 数组\n\n- 一旦创建数组，就不能改变长度，若需要改变长度，使用list\n\n- 使用=可以完成浅拷贝，若要深拷贝，需要使用Array.copyOf（）方法\n\n- 生成随机数：Math.random()返回0到1之间随机的浮点数，n*Math.random()就可以得到0到n-1的一个随机数。\n\n\n","source":"_posts/Java核心技术卷一学习（一）.md","raw":"---\ntitle: Java核心技术卷一学习笔记（一）\ndate: 2021-02-08 12:31:14\ntags: Java学习\n---\n\n# Java的基本程序设计结构\n\n<!--more-->\n\n## 1 一个简单的Java应用程序\n\n- Java应用程序中的全部内容都必须放置在类中\n\n- 命名规范：类名必须以大写字母开头，若名字有多个单词组成，则每个单词首字母都大写，驼峰命名法\n\n- 源代码文件名必须与该文件中的公共类名字相同\n\n- Java1.4以后，main方法必须是public\n\n- 输出：println方法会在输出后增加一个换行符，若不需要，使用print方法\n\n## 2 数据类型\n\n- Java是一种强类型语言。每一个变量都需要声明一种类型。\n\n- Java与C++不同，整型不会根据不同的处理器选择不同大小，int统一为4字节，short为2字节，long为8字节，byte为1字节。\n\n- 从Java7开始，用0b开头表示二进制数\n\n- 从Java7开始，数字字面量可以添加下划线，编译器会去除下划线，如1_000_000等价于1000000\n\n- Integer类和Long类都提供了处理无符号数的方法\n\n## 3 浮点类型\n\n- 没有后缀F的默认为double型\n\n- 不能使用 x==Double.NaN来判断一个特定值是否不为数字，而应该使用Double.isNaN（x）\n\n## 4 Unicode与char类型\n\n- 码点（codePoint）是指一个与编码表中的某个字符对应的代码值\n\n- char类型代表一个字符，即一个代码单元\n\n- 不可用char来存储一个码点，因为一个码点可能对应两个代码单元\n\n## 5 变量\n\n- 如果可以从变量的初始值判断数值类型，就不需要再声明类型，使用var关键字即可\n\n```\nvar x = 12;//x为int型\nvar y = \"hello\";//y为string\n```\n\n- 与C++不同，Java常量关键字使用final，若某个常量需要被多个方法使用，声明为static final，若需要在类外使用，声明为public static final ，通过Object.*cast*使用即可。\n\n- 枚举类型：枚举类型变量只能储存在这个类型声明中给定的某个枚举值或者null\n\n## 6 位运算符\n\n- “>>>”运算符会用0填充高位，而“>>“会根据符号位填充\n\n- 移位运算符的右操作数要完成模32的运算（若左操作数为long，则要模64），如1<<35 等价于 1<<3\n\n## 7 字符串\n\n- Java的String是一个类，不是一个字符串，与C++不同，String也不是一个字符数组，而类似与字符串指针，但不能采用指针的方式运算。\n\n- Java的String类是不可变的，因此字符串在存储池中是可以共享的，如果某个字符块不再使用，Java会自动回收，不会造成内存泄漏。\n\n- 由于String对象类似指针，因此不可使用==来比较两个字符串是否相等，因为两个对象可能共享同一个字符串，需要使用equals方法。\n\n- 如果在一个null值上调用方法，会抛出异常。\n\n- String、StringBuffer、StringBuilder对比\n\n    - String为不可变的，虽然两个String对象可以相加，但每次拼接，都会构建一个新的字符串，耗时且浪费空间。可以等价于：\n\n    ```\n    public final class String\n    {\n        private final char value[];\n        ···\n    }\n    ```\n\n    - 而StringBuffer和StringBuilder底层等价于一个普通数组，是可变的，因此拼接字符串时是对其本身对象进行操作，不会产生新的对象。使用.append方法即可拼接字符串。\n\n    - StringBuffer与StringBuilder，前者是线程安全的，因为其中很多方法被synchronized修饰，相当于锁机制，而后者没有，但后者效率偏高。\n\n    - 如果会多次修改字符串，且不考虑线程安全，使用StringBuilder，考虑线程安全应该使用StringBuffer。\n\n## 8 输入输出\n\n- 输入需要创建Scanner对象：\n\n```\nScanner in = new Scanner(System.in);\nString name = in.nextLine();//一行字符串，包括空格\nString name = in.next();//一个单词，不包括空格\nint age = in.nextInt();//输入数字\n```\n\n如果需要输入密码，应该使用Console，在控制台不会显示出输入的密码，输入完成后应立即覆盖数组：\n\n```\nConsole cons = System.console();\nString username = cons.readLine(\"user name:\");\nchar [] password = cons.readPassword(\"Password:\");\n```\n\n- 格式化输出：可以用一个格式字符串指示要格式化的索引\n\n```\nSyetem.out.println(\"%1$s %2$tB %2$te %2$tY\",\"Dut Date:\",new Date());\n```\n\n- 文件输入输出：同样需要一个Scanner对象：\n\n```\nScanner in = new Scanner(Path.of(\"myfile.txt\"),StandardCharsets.UFT-8);\n```\n\n注意：可以构造一个参数为字符串的Scanner对象，但会把字符串解析为数据而不是文件名\n\n## 9 控制流程\n\n- Java中不允许在嵌套的块内有多个同名变量\n\n- 循环时，检测两个浮点数要格外小心，因为舍入误差可能造成死循环\n\n```\nfor(double x = 0;x!=10;x+=0.1) ...\n```\n\n- Java中没有goto语句，但break可以有标签，在标签指定的循环中使用 break 标签可以跳出最外层循环\n\n## 10 数组\n\n- 一旦创建数组，就不能改变长度，若需要改变长度，使用list\n\n- 使用=可以完成浅拷贝，若要深拷贝，需要使用Array.copyOf（）方法\n\n- 生成随机数：Math.random()返回0到1之间随机的浮点数，n*Math.random()就可以得到0到n-1的一个随机数。\n\n\n","slug":"Java核心技术卷一学习（一）","published":1,"updated":"2021-02-13T10:44:16.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckl3lg6n60001z09j9k1r68av","content":"<h1 id=\"Java的基本程序设计结构\"><a href=\"#Java的基本程序设计结构\" class=\"headerlink\" title=\"Java的基本程序设计结构\"></a>Java的基本程序设计结构</h1><a id=\"more\"></a>\n\n<h2 id=\"1-一个简单的Java应用程序\"><a href=\"#1-一个简单的Java应用程序\" class=\"headerlink\" title=\"1 一个简单的Java应用程序\"></a>1 一个简单的Java应用程序</h2><ul>\n<li><p>Java应用程序中的全部内容都必须放置在类中</p>\n</li>\n<li><p>命名规范：类名必须以大写字母开头，若名字有多个单词组成，则每个单词首字母都大写，驼峰命名法</p>\n</li>\n<li><p>源代码文件名必须与该文件中的公共类名字相同</p>\n</li>\n<li><p>Java1.4以后，main方法必须是public</p>\n</li>\n<li><p>输出：println方法会在输出后增加一个换行符，若不需要，使用print方法</p>\n</li>\n</ul>\n<h2 id=\"2-数据类型\"><a href=\"#2-数据类型\" class=\"headerlink\" title=\"2 数据类型\"></a>2 数据类型</h2><ul>\n<li><p>Java是一种强类型语言。每一个变量都需要声明一种类型。</p>\n</li>\n<li><p>Java与C++不同，整型不会根据不同的处理器选择不同大小，int统一为4字节，short为2字节，long为8字节，byte为1字节。</p>\n</li>\n<li><p>从Java7开始，用0b开头表示二进制数</p>\n</li>\n<li><p>从Java7开始，数字字面量可以添加下划线，编译器会去除下划线，如1_000_000等价于1000000</p>\n</li>\n<li><p>Integer类和Long类都提供了处理无符号数的方法</p>\n</li>\n</ul>\n<h2 id=\"3-浮点类型\"><a href=\"#3-浮点类型\" class=\"headerlink\" title=\"3 浮点类型\"></a>3 浮点类型</h2><ul>\n<li><p>没有后缀F的默认为double型</p>\n</li>\n<li><p>不能使用 x==Double.NaN来判断一个特定值是否不为数字，而应该使用Double.isNaN（x）</p>\n</li>\n</ul>\n<h2 id=\"4-Unicode与char类型\"><a href=\"#4-Unicode与char类型\" class=\"headerlink\" title=\"4 Unicode与char类型\"></a>4 Unicode与char类型</h2><ul>\n<li><p>码点（codePoint）是指一个与编码表中的某个字符对应的代码值</p>\n</li>\n<li><p>char类型代表一个字符，即一个代码单元</p>\n</li>\n<li><p>不可用char来存储一个码点，因为一个码点可能对应两个代码单元</p>\n</li>\n</ul>\n<h2 id=\"5-变量\"><a href=\"#5-变量\" class=\"headerlink\" title=\"5 变量\"></a>5 变量</h2><ul>\n<li>如果可以从变量的初始值判断数值类型，就不需要再声明类型，使用var关键字即可</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x &#x3D; 12;&#x2F;&#x2F;x为int型</span><br><span class=\"line\">var y &#x3D; &quot;hello&quot;;&#x2F;&#x2F;y为string</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>与C++不同，Java常量关键字使用final，若某个常量需要被多个方法使用，声明为static final，若需要在类外使用，声明为public static final ，通过Object.<em>cast</em>使用即可。</p>\n</li>\n<li><p>枚举类型：枚举类型变量只能储存在这个类型声明中给定的某个枚举值或者null</p>\n</li>\n</ul>\n<h2 id=\"6-位运算符\"><a href=\"#6-位运算符\" class=\"headerlink\" title=\"6 位运算符\"></a>6 位运算符</h2><ul>\n<li><p>“&gt;&gt;&gt;”运算符会用0填充高位，而“&gt;&gt;“会根据符号位填充</p>\n</li>\n<li><p>移位运算符的右操作数要完成模32的运算（若左操作数为long，则要模64），如1&lt;&lt;35 等价于 1&lt;&lt;3</p>\n</li>\n</ul>\n<h2 id=\"7-字符串\"><a href=\"#7-字符串\" class=\"headerlink\" title=\"7 字符串\"></a>7 字符串</h2><ul>\n<li><p>Java的String是一个类，不是一个字符串，与C++不同，String也不是一个字符数组，而类似与字符串指针，但不能采用指针的方式运算。</p>\n</li>\n<li><p>Java的String类是不可变的，因此字符串在存储池中是可以共享的，如果某个字符块不再使用，Java会自动回收，不会造成内存泄漏。</p>\n</li>\n<li><p>由于String对象类似指针，因此不可使用==来比较两个字符串是否相等，因为两个对象可能共享同一个字符串，需要使用equals方法。</p>\n</li>\n<li><p>如果在一个null值上调用方法，会抛出异常。</p>\n</li>\n<li><p>String、StringBuffer、StringBuilder对比</p>\n<ul>\n<li><p>String为不可变的，虽然两个String对象可以相加，但每次拼接，都会构建一个新的字符串，耗时且浪费空间。可以等价于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class String</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private final char value[];</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>而StringBuffer和StringBuilder底层等价于一个普通数组，是可变的，因此拼接字符串时是对其本身对象进行操作，不会产生新的对象。使用.append方法即可拼接字符串。</p>\n</li>\n<li><p>StringBuffer与StringBuilder，前者是线程安全的，因为其中很多方法被synchronized修饰，相当于锁机制，而后者没有，但后者效率偏高。</p>\n</li>\n<li><p>如果会多次修改字符串，且不考虑线程安全，使用StringBuilder，考虑线程安全应该使用StringBuffer。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"8-输入输出\"><a href=\"#8-输入输出\" class=\"headerlink\" title=\"8 输入输出\"></a>8 输入输出</h2><ul>\n<li>输入需要创建Scanner对象：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scanner in &#x3D; new Scanner(System.in);</span><br><span class=\"line\">String name &#x3D; in.nextLine();&#x2F;&#x2F;一行字符串，包括空格</span><br><span class=\"line\">String name &#x3D; in.next();&#x2F;&#x2F;一个单词，不包括空格</span><br><span class=\"line\">int age &#x3D; in.nextInt();&#x2F;&#x2F;输入数字</span><br></pre></td></tr></table></figure>\n<p>如果需要输入密码，应该使用Console，在控制台不会显示出输入的密码，输入完成后应立即覆盖数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Console cons &#x3D; System.console();</span><br><span class=\"line\">String username &#x3D; cons.readLine(&quot;user name:&quot;);</span><br><span class=\"line\">char [] password &#x3D; cons.readPassword(&quot;Password:&quot;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>格式化输出：可以用一个格式字符串指示要格式化的索引</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Syetem.out.println(&quot;%1$s %2$tB %2$te %2$tY&quot;,&quot;Dut Date:&quot;,new Date());</span><br></pre></td></tr></table></figure>\n<ul>\n<li>文件输入输出：同样需要一个Scanner对象：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scanner in &#x3D; new Scanner(Path.of(&quot;myfile.txt&quot;),StandardCharsets.UFT-8);</span><br></pre></td></tr></table></figure>\n<p>注意：可以构造一个参数为字符串的Scanner对象，但会把字符串解析为数据而不是文件名</p>\n<h2 id=\"9-控制流程\"><a href=\"#9-控制流程\" class=\"headerlink\" title=\"9 控制流程\"></a>9 控制流程</h2><ul>\n<li><p>Java中不允许在嵌套的块内有多个同名变量</p>\n</li>\n<li><p>循环时，检测两个浮点数要格外小心，因为舍入误差可能造成死循环</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(double x &#x3D; 0;x!&#x3D;10;x+&#x3D;0.1) ...</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Java中没有goto语句，但break可以有标签，在标签指定的循环中使用 break 标签可以跳出最外层循环</li>\n</ul>\n<h2 id=\"10-数组\"><a href=\"#10-数组\" class=\"headerlink\" title=\"10 数组\"></a>10 数组</h2><ul>\n<li><p>一旦创建数组，就不能改变长度，若需要改变长度，使用list</p>\n</li>\n<li><p>使用=可以完成浅拷贝，若要深拷贝，需要使用Array.copyOf（）方法</p>\n</li>\n<li><p>生成随机数：Math.random()返回0到1之间随机的浮点数，n*Math.random()就可以得到0到n-1的一个随机数。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"Java的基本程序设计结构\"><a href=\"#Java的基本程序设计结构\" class=\"headerlink\" title=\"Java的基本程序设计结构\"></a>Java的基本程序设计结构</h1>","more":"<h2 id=\"1-一个简单的Java应用程序\"><a href=\"#1-一个简单的Java应用程序\" class=\"headerlink\" title=\"1 一个简单的Java应用程序\"></a>1 一个简单的Java应用程序</h2><ul>\n<li><p>Java应用程序中的全部内容都必须放置在类中</p>\n</li>\n<li><p>命名规范：类名必须以大写字母开头，若名字有多个单词组成，则每个单词首字母都大写，驼峰命名法</p>\n</li>\n<li><p>源代码文件名必须与该文件中的公共类名字相同</p>\n</li>\n<li><p>Java1.4以后，main方法必须是public</p>\n</li>\n<li><p>输出：println方法会在输出后增加一个换行符，若不需要，使用print方法</p>\n</li>\n</ul>\n<h2 id=\"2-数据类型\"><a href=\"#2-数据类型\" class=\"headerlink\" title=\"2 数据类型\"></a>2 数据类型</h2><ul>\n<li><p>Java是一种强类型语言。每一个变量都需要声明一种类型。</p>\n</li>\n<li><p>Java与C++不同，整型不会根据不同的处理器选择不同大小，int统一为4字节，short为2字节，long为8字节，byte为1字节。</p>\n</li>\n<li><p>从Java7开始，用0b开头表示二进制数</p>\n</li>\n<li><p>从Java7开始，数字字面量可以添加下划线，编译器会去除下划线，如1_000_000等价于1000000</p>\n</li>\n<li><p>Integer类和Long类都提供了处理无符号数的方法</p>\n</li>\n</ul>\n<h2 id=\"3-浮点类型\"><a href=\"#3-浮点类型\" class=\"headerlink\" title=\"3 浮点类型\"></a>3 浮点类型</h2><ul>\n<li><p>没有后缀F的默认为double型</p>\n</li>\n<li><p>不能使用 x==Double.NaN来判断一个特定值是否不为数字，而应该使用Double.isNaN（x）</p>\n</li>\n</ul>\n<h2 id=\"4-Unicode与char类型\"><a href=\"#4-Unicode与char类型\" class=\"headerlink\" title=\"4 Unicode与char类型\"></a>4 Unicode与char类型</h2><ul>\n<li><p>码点（codePoint）是指一个与编码表中的某个字符对应的代码值</p>\n</li>\n<li><p>char类型代表一个字符，即一个代码单元</p>\n</li>\n<li><p>不可用char来存储一个码点，因为一个码点可能对应两个代码单元</p>\n</li>\n</ul>\n<h2 id=\"5-变量\"><a href=\"#5-变量\" class=\"headerlink\" title=\"5 变量\"></a>5 变量</h2><ul>\n<li>如果可以从变量的初始值判断数值类型，就不需要再声明类型，使用var关键字即可</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x &#x3D; 12;&#x2F;&#x2F;x为int型</span><br><span class=\"line\">var y &#x3D; &quot;hello&quot;;&#x2F;&#x2F;y为string</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>与C++不同，Java常量关键字使用final，若某个常量需要被多个方法使用，声明为static final，若需要在类外使用，声明为public static final ，通过Object.<em>cast</em>使用即可。</p>\n</li>\n<li><p>枚举类型：枚举类型变量只能储存在这个类型声明中给定的某个枚举值或者null</p>\n</li>\n</ul>\n<h2 id=\"6-位运算符\"><a href=\"#6-位运算符\" class=\"headerlink\" title=\"6 位运算符\"></a>6 位运算符</h2><ul>\n<li><p>“&gt;&gt;&gt;”运算符会用0填充高位，而“&gt;&gt;“会根据符号位填充</p>\n</li>\n<li><p>移位运算符的右操作数要完成模32的运算（若左操作数为long，则要模64），如1&lt;&lt;35 等价于 1&lt;&lt;3</p>\n</li>\n</ul>\n<h2 id=\"7-字符串\"><a href=\"#7-字符串\" class=\"headerlink\" title=\"7 字符串\"></a>7 字符串</h2><ul>\n<li><p>Java的String是一个类，不是一个字符串，与C++不同，String也不是一个字符数组，而类似与字符串指针，但不能采用指针的方式运算。</p>\n</li>\n<li><p>Java的String类是不可变的，因此字符串在存储池中是可以共享的，如果某个字符块不再使用，Java会自动回收，不会造成内存泄漏。</p>\n</li>\n<li><p>由于String对象类似指针，因此不可使用==来比较两个字符串是否相等，因为两个对象可能共享同一个字符串，需要使用equals方法。</p>\n</li>\n<li><p>如果在一个null值上调用方法，会抛出异常。</p>\n</li>\n<li><p>String、StringBuffer、StringBuilder对比</p>\n<ul>\n<li><p>String为不可变的，虽然两个String对象可以相加，但每次拼接，都会构建一个新的字符串，耗时且浪费空间。可以等价于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class String</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private final char value[];</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>而StringBuffer和StringBuilder底层等价于一个普通数组，是可变的，因此拼接字符串时是对其本身对象进行操作，不会产生新的对象。使用.append方法即可拼接字符串。</p>\n</li>\n<li><p>StringBuffer与StringBuilder，前者是线程安全的，因为其中很多方法被synchronized修饰，相当于锁机制，而后者没有，但后者效率偏高。</p>\n</li>\n<li><p>如果会多次修改字符串，且不考虑线程安全，使用StringBuilder，考虑线程安全应该使用StringBuffer。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"8-输入输出\"><a href=\"#8-输入输出\" class=\"headerlink\" title=\"8 输入输出\"></a>8 输入输出</h2><ul>\n<li>输入需要创建Scanner对象：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scanner in &#x3D; new Scanner(System.in);</span><br><span class=\"line\">String name &#x3D; in.nextLine();&#x2F;&#x2F;一行字符串，包括空格</span><br><span class=\"line\">String name &#x3D; in.next();&#x2F;&#x2F;一个单词，不包括空格</span><br><span class=\"line\">int age &#x3D; in.nextInt();&#x2F;&#x2F;输入数字</span><br></pre></td></tr></table></figure>\n<p>如果需要输入密码，应该使用Console，在控制台不会显示出输入的密码，输入完成后应立即覆盖数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Console cons &#x3D; System.console();</span><br><span class=\"line\">String username &#x3D; cons.readLine(&quot;user name:&quot;);</span><br><span class=\"line\">char [] password &#x3D; cons.readPassword(&quot;Password:&quot;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>格式化输出：可以用一个格式字符串指示要格式化的索引</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Syetem.out.println(&quot;%1$s %2$tB %2$te %2$tY&quot;,&quot;Dut Date:&quot;,new Date());</span><br></pre></td></tr></table></figure>\n<ul>\n<li>文件输入输出：同样需要一个Scanner对象：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scanner in &#x3D; new Scanner(Path.of(&quot;myfile.txt&quot;),StandardCharsets.UFT-8);</span><br></pre></td></tr></table></figure>\n<p>注意：可以构造一个参数为字符串的Scanner对象，但会把字符串解析为数据而不是文件名</p>\n<h2 id=\"9-控制流程\"><a href=\"#9-控制流程\" class=\"headerlink\" title=\"9 控制流程\"></a>9 控制流程</h2><ul>\n<li><p>Java中不允许在嵌套的块内有多个同名变量</p>\n</li>\n<li><p>循环时，检测两个浮点数要格外小心，因为舍入误差可能造成死循环</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(double x &#x3D; 0;x!&#x3D;10;x+&#x3D;0.1) ...</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Java中没有goto语句，但break可以有标签，在标签指定的循环中使用 break 标签可以跳出最外层循环</li>\n</ul>\n<h2 id=\"10-数组\"><a href=\"#10-数组\" class=\"headerlink\" title=\"10 数组\"></a>10 数组</h2><ul>\n<li><p>一旦创建数组，就不能改变长度，若需要改变长度，使用list</p>\n</li>\n<li><p>使用=可以完成浅拷贝，若要深拷贝，需要使用Array.copyOf（）方法</p>\n</li>\n<li><p>生成随机数：Math.random()返回0到1之间随机的浮点数，n*Math.random()就可以得到0到n-1的一个随机数。</p>\n</li>\n</ul>"},{"title":"二叉树的遍历非递归算法","date":"2021-02-13T10:26:15.000Z","_content":"\n\n\n# 前序算法\n\n<!--more-->\n\n前序非递归算法最简单，每遍历一个节点先输出值，再将右子树，左子树依次入栈，当栈不为空，用栈顶元素重复上述操作即可。\n\n```\nstatus Pre_order_b(BiTree T, status(*Visit)(BiTree T)) {\n    BiTree st[MAXSIZE];\n    BiTree p;\n    int top = 0; //置空栈\n    if (T) {\n        st[top++] = T;\n        while (top)\n        {\n            p = st[--top]; //弹出栈顶指针\n            if(!Visit(p)) return ERROR;\n            if (p->rchild != NULL) st[top++] = p->rchild; //将右子树的根结点存入栈中\n            if (p->lchild != NULL) st[top++] = p->lchild; //将左子树的根结点存入栈中\n        }\n        \n    }\n    return OK;\n}\n```\n\n# 中序算法\n\n中序算法与前序算法不同之处在于输出的时候不同,先将所有左节点入栈，当碰到叶子节点或者没有左子树的节点就输出，继续遍历右子树，重复上述步骤直到栈为空。\n\n```\nusing namespace std;\n \nvoid InorderTraversal(TreeNode BT)\n{\n    TreeNode T;\n    stack<TreeNode> BtStack;\n    T = BT;\n    while (T || !BtStack.empty())\n    {\n        while (T)\n        {\n            BtStack.push(T);\n            T = T->Left;\n        }\n        T = BtStack.top();\n        BtStack.pop();\n        printf(\"%c \", T->Data);\n        T = T->Right;\n \n    }\n}\n```\n\n# 后序算法\n\n后序遍历是二叉树的三种非递归遍历中最难的一种，其难点在于怎么从root->right转换到root节点。\n\n步骤：\n\n对于树中任意一个访问的节点p可以分情况讨论\n\n1. p如果是叶子节点，直接输出\n\n2. p如果有孩子，且孩子没有被访问过，则按照右孩子，左孩子的顺序依次入栈\n\n3. p如果有孩子，而且孩子都已经访问过，则访问p节点\n\n如何来表示出p的孩是否都已经访问过了呢？最简单的方法就是对每个节点的状态进行保存，这么做显然是可以的，但是空间复杂度太大。我们可以保存最后一个访问的节点last，如果满足 (p->right==NULL && last ==p->left) || last=p->right，那么显然p的孩子都访问过了，接下来可以访问p。\n\n```\nvoid postOrder(TreeNode *root)\n{\n    if(root == NULL) return ;\n \n    TreeNode *p = root;\n    stack<TreeNode *> sta;\n    TreeNode *last = root;\n    sta.push(p);\n    while (!sta.empty())\n    {\n        p = sta.top();\n        if( (p->left == NULL && p->right == NULL) || (p->right == NULL && last == p->left) || (last == p->right) )\n        {\n            printf(\"%c \", p->Data);\n            last = p;\n            sta.pop();\n        }\n        else \n        {\n            if(p->right)\n                sta.push(p->right);\n            if(p->left)\n                sta.push(p->left);\n        }\n \n    }\n \n}\n```\n","source":"_posts/二叉树的遍历非递归算法.md","raw":"---\ntitle: 二叉树的遍历非递归算法\ndate: 2021-02-13 18:26:15\ntags: 数据结构与算法\n---\n\n\n\n# 前序算法\n\n<!--more-->\n\n前序非递归算法最简单，每遍历一个节点先输出值，再将右子树，左子树依次入栈，当栈不为空，用栈顶元素重复上述操作即可。\n\n```\nstatus Pre_order_b(BiTree T, status(*Visit)(BiTree T)) {\n    BiTree st[MAXSIZE];\n    BiTree p;\n    int top = 0; //置空栈\n    if (T) {\n        st[top++] = T;\n        while (top)\n        {\n            p = st[--top]; //弹出栈顶指针\n            if(!Visit(p)) return ERROR;\n            if (p->rchild != NULL) st[top++] = p->rchild; //将右子树的根结点存入栈中\n            if (p->lchild != NULL) st[top++] = p->lchild; //将左子树的根结点存入栈中\n        }\n        \n    }\n    return OK;\n}\n```\n\n# 中序算法\n\n中序算法与前序算法不同之处在于输出的时候不同,先将所有左节点入栈，当碰到叶子节点或者没有左子树的节点就输出，继续遍历右子树，重复上述步骤直到栈为空。\n\n```\nusing namespace std;\n \nvoid InorderTraversal(TreeNode BT)\n{\n    TreeNode T;\n    stack<TreeNode> BtStack;\n    T = BT;\n    while (T || !BtStack.empty())\n    {\n        while (T)\n        {\n            BtStack.push(T);\n            T = T->Left;\n        }\n        T = BtStack.top();\n        BtStack.pop();\n        printf(\"%c \", T->Data);\n        T = T->Right;\n \n    }\n}\n```\n\n# 后序算法\n\n后序遍历是二叉树的三种非递归遍历中最难的一种，其难点在于怎么从root->right转换到root节点。\n\n步骤：\n\n对于树中任意一个访问的节点p可以分情况讨论\n\n1. p如果是叶子节点，直接输出\n\n2. p如果有孩子，且孩子没有被访问过，则按照右孩子，左孩子的顺序依次入栈\n\n3. p如果有孩子，而且孩子都已经访问过，则访问p节点\n\n如何来表示出p的孩是否都已经访问过了呢？最简单的方法就是对每个节点的状态进行保存，这么做显然是可以的，但是空间复杂度太大。我们可以保存最后一个访问的节点last，如果满足 (p->right==NULL && last ==p->left) || last=p->right，那么显然p的孩子都访问过了，接下来可以访问p。\n\n```\nvoid postOrder(TreeNode *root)\n{\n    if(root == NULL) return ;\n \n    TreeNode *p = root;\n    stack<TreeNode *> sta;\n    TreeNode *last = root;\n    sta.push(p);\n    while (!sta.empty())\n    {\n        p = sta.top();\n        if( (p->left == NULL && p->right == NULL) || (p->right == NULL && last == p->left) || (last == p->right) )\n        {\n            printf(\"%c \", p->Data);\n            last = p;\n            sta.pop();\n        }\n        else \n        {\n            if(p->right)\n                sta.push(p->right);\n            if(p->left)\n                sta.push(p->left);\n        }\n \n    }\n \n}\n```\n","slug":"二叉树的遍历非递归算法","published":1,"updated":"2021-02-13T10:45:30.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckl3lg6n90003z09j2eqadock","content":"<h1 id=\"前序算法\"><a href=\"#前序算法\" class=\"headerlink\" title=\"前序算法\"></a>前序算法</h1><a id=\"more\"></a>\n\n<p>前序非递归算法最简单，每遍历一个节点先输出值，再将右子树，左子树依次入栈，当栈不为空，用栈顶元素重复上述操作即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">status Pre_order_b(BiTree T, status(*Visit)(BiTree T)) &#123;</span><br><span class=\"line\">    BiTree st[MAXSIZE];</span><br><span class=\"line\">    BiTree p;</span><br><span class=\"line\">    int top &#x3D; 0; &#x2F;&#x2F;置空栈</span><br><span class=\"line\">    if (T) &#123;</span><br><span class=\"line\">        st[top++] &#x3D; T;</span><br><span class=\"line\">        while (top)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            p &#x3D; st[--top]; &#x2F;&#x2F;弹出栈顶指针</span><br><span class=\"line\">            if(!Visit(p)) return ERROR;</span><br><span class=\"line\">            if (p-&gt;rchild !&#x3D; NULL) st[top++] &#x3D; p-&gt;rchild; &#x2F;&#x2F;将右子树的根结点存入栈中</span><br><span class=\"line\">            if (p-&gt;lchild !&#x3D; NULL) st[top++] &#x3D; p-&gt;lchild; &#x2F;&#x2F;将左子树的根结点存入栈中</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"中序算法\"><a href=\"#中序算法\" class=\"headerlink\" title=\"中序算法\"></a>中序算法</h1><p>中序算法与前序算法不同之处在于输出的时候不同,先将所有左节点入栈，当碰到叶子节点或者没有左子树的节点就输出，继续遍历右子树，重复上述步骤直到栈为空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using namespace std;</span><br><span class=\"line\"> </span><br><span class=\"line\">void InorderTraversal(TreeNode BT)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TreeNode T;</span><br><span class=\"line\">    stack&lt;TreeNode&gt; BtStack;</span><br><span class=\"line\">    T &#x3D; BT;</span><br><span class=\"line\">    while (T || !BtStack.empty())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        while (T)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            BtStack.push(T);</span><br><span class=\"line\">            T &#x3D; T-&gt;Left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        T &#x3D; BtStack.top();</span><br><span class=\"line\">        BtStack.pop();</span><br><span class=\"line\">        printf(&quot;%c &quot;, T-&gt;Data);</span><br><span class=\"line\">        T &#x3D; T-&gt;Right;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"后序算法\"><a href=\"#后序算法\" class=\"headerlink\" title=\"后序算法\"></a>后序算法</h1><p>后序遍历是二叉树的三种非递归遍历中最难的一种，其难点在于怎么从root-&gt;right转换到root节点。</p>\n<p>步骤：</p>\n<p>对于树中任意一个访问的节点p可以分情况讨论</p>\n<ol>\n<li><p>p如果是叶子节点，直接输出</p>\n</li>\n<li><p>p如果有孩子，且孩子没有被访问过，则按照右孩子，左孩子的顺序依次入栈</p>\n</li>\n<li><p>p如果有孩子，而且孩子都已经访问过，则访问p节点</p>\n</li>\n</ol>\n<p>如何来表示出p的孩是否都已经访问过了呢？最简单的方法就是对每个节点的状态进行保存，这么做显然是可以的，但是空间复杂度太大。我们可以保存最后一个访问的节点last，如果满足 (p-&gt;right==NULL &amp;&amp; last ==p-&gt;left) || last=p-&gt;right，那么显然p的孩子都访问过了，接下来可以访问p。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void postOrder(TreeNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(root &#x3D;&#x3D; NULL) return ;</span><br><span class=\"line\"> </span><br><span class=\"line\">    TreeNode *p &#x3D; root;</span><br><span class=\"line\">    stack&lt;TreeNode *&gt; sta;</span><br><span class=\"line\">    TreeNode *last &#x3D; root;</span><br><span class=\"line\">    sta.push(p);</span><br><span class=\"line\">    while (!sta.empty())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p &#x3D; sta.top();</span><br><span class=\"line\">        if( (p-&gt;left &#x3D;&#x3D; NULL &amp;&amp; p-&gt;right &#x3D;&#x3D; NULL) || (p-&gt;right &#x3D;&#x3D; NULL &amp;&amp; last &#x3D;&#x3D; p-&gt;left) || (last &#x3D;&#x3D; p-&gt;right) )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            printf(&quot;%c &quot;, p-&gt;Data);</span><br><span class=\"line\">            last &#x3D; p;</span><br><span class=\"line\">            sta.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if(p-&gt;right)</span><br><span class=\"line\">                sta.push(p-&gt;right);</span><br><span class=\"line\">            if(p-&gt;left)</span><br><span class=\"line\">                sta.push(p-&gt;left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"前序算法\"><a href=\"#前序算法\" class=\"headerlink\" title=\"前序算法\"></a>前序算法</h1>","more":"<p>前序非递归算法最简单，每遍历一个节点先输出值，再将右子树，左子树依次入栈，当栈不为空，用栈顶元素重复上述操作即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">status Pre_order_b(BiTree T, status(*Visit)(BiTree T)) &#123;</span><br><span class=\"line\">    BiTree st[MAXSIZE];</span><br><span class=\"line\">    BiTree p;</span><br><span class=\"line\">    int top &#x3D; 0; &#x2F;&#x2F;置空栈</span><br><span class=\"line\">    if (T) &#123;</span><br><span class=\"line\">        st[top++] &#x3D; T;</span><br><span class=\"line\">        while (top)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            p &#x3D; st[--top]; &#x2F;&#x2F;弹出栈顶指针</span><br><span class=\"line\">            if(!Visit(p)) return ERROR;</span><br><span class=\"line\">            if (p-&gt;rchild !&#x3D; NULL) st[top++] &#x3D; p-&gt;rchild; &#x2F;&#x2F;将右子树的根结点存入栈中</span><br><span class=\"line\">            if (p-&gt;lchild !&#x3D; NULL) st[top++] &#x3D; p-&gt;lchild; &#x2F;&#x2F;将左子树的根结点存入栈中</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"中序算法\"><a href=\"#中序算法\" class=\"headerlink\" title=\"中序算法\"></a>中序算法</h1><p>中序算法与前序算法不同之处在于输出的时候不同,先将所有左节点入栈，当碰到叶子节点或者没有左子树的节点就输出，继续遍历右子树，重复上述步骤直到栈为空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using namespace std;</span><br><span class=\"line\"> </span><br><span class=\"line\">void InorderTraversal(TreeNode BT)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TreeNode T;</span><br><span class=\"line\">    stack&lt;TreeNode&gt; BtStack;</span><br><span class=\"line\">    T &#x3D; BT;</span><br><span class=\"line\">    while (T || !BtStack.empty())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        while (T)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            BtStack.push(T);</span><br><span class=\"line\">            T &#x3D; T-&gt;Left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        T &#x3D; BtStack.top();</span><br><span class=\"line\">        BtStack.pop();</span><br><span class=\"line\">        printf(&quot;%c &quot;, T-&gt;Data);</span><br><span class=\"line\">        T &#x3D; T-&gt;Right;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"后序算法\"><a href=\"#后序算法\" class=\"headerlink\" title=\"后序算法\"></a>后序算法</h1><p>后序遍历是二叉树的三种非递归遍历中最难的一种，其难点在于怎么从root-&gt;right转换到root节点。</p>\n<p>步骤：</p>\n<p>对于树中任意一个访问的节点p可以分情况讨论</p>\n<ol>\n<li><p>p如果是叶子节点，直接输出</p>\n</li>\n<li><p>p如果有孩子，且孩子没有被访问过，则按照右孩子，左孩子的顺序依次入栈</p>\n</li>\n<li><p>p如果有孩子，而且孩子都已经访问过，则访问p节点</p>\n</li>\n</ol>\n<p>如何来表示出p的孩是否都已经访问过了呢？最简单的方法就是对每个节点的状态进行保存，这么做显然是可以的，但是空间复杂度太大。我们可以保存最后一个访问的节点last，如果满足 (p-&gt;right==NULL &amp;&amp; last ==p-&gt;left) || last=p-&gt;right，那么显然p的孩子都访问过了，接下来可以访问p。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void postOrder(TreeNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(root &#x3D;&#x3D; NULL) return ;</span><br><span class=\"line\"> </span><br><span class=\"line\">    TreeNode *p &#x3D; root;</span><br><span class=\"line\">    stack&lt;TreeNode *&gt; sta;</span><br><span class=\"line\">    TreeNode *last &#x3D; root;</span><br><span class=\"line\">    sta.push(p);</span><br><span class=\"line\">    while (!sta.empty())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p &#x3D; sta.top();</span><br><span class=\"line\">        if( (p-&gt;left &#x3D;&#x3D; NULL &amp;&amp; p-&gt;right &#x3D;&#x3D; NULL) || (p-&gt;right &#x3D;&#x3D; NULL &amp;&amp; last &#x3D;&#x3D; p-&gt;left) || (last &#x3D;&#x3D; p-&gt;right) )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            printf(&quot;%c &quot;, p-&gt;Data);</span><br><span class=\"line\">            last &#x3D; p;</span><br><span class=\"line\">            sta.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if(p-&gt;right)</span><br><span class=\"line\">                sta.push(p-&gt;right);</span><br><span class=\"line\">            if(p-&gt;left)</span><br><span class=\"line\">                sta.push(p-&gt;left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckl3lg6n10000z09j3a481kwq","tag_id":"ckl3lg6n80002z09jaiwv7axw","_id":"ckl3lg6nd0005z09jg7gydccq"},{"post_id":"ckl3lg6n60001z09j9k1r68av","tag_id":"ckl3lg6n80002z09jaiwv7axw","_id":"ckl3lg6nd0007z09j1ag93ldg"},{"post_id":"ckl3lg6n90003z09j2eqadock","tag_id":"ckl3lg6nd0006z09jhqw5djxx","_id":"ckl3lg6ne0008z09j9v7q6qar"}],"Tag":[{"name":"Java学习","_id":"ckl3lg6n80002z09jaiwv7axw"},{"name":"数据结构与算法","_id":"ckl3lg6nd0006z09jhqw5djxx"}]}}